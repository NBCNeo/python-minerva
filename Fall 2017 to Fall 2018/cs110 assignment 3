# The following 7 strings were generated by taking an existing string and with a small probability either inserting a new character, deleting an existing character, or changing to a new character randomly. This created two child strings, each of these strings with a single character changed from their parent. And from the two child strings, four grandchild strings were created, two from each child. The 4 grandchild strings also have a single character changed from their parents. As result, we #got 7 strings but unfortunately the order of the strings has been lost.
#
# (0, 'CAGCGGGTGCGTAATTTGGAGAAGTTATTCTGCAACGAAATCAATCCTGTTTCGTTAGCTTACGGACTACGACGAGAGGGTACTTCCCTGATATAGTCAC')
# (1, 'CAAGTCGGGCGTATTGGAGAATATTTAAATCGGAAGATCATGTTACTATGCGTTAGCTCACGGACTGAAGAGGATTCTCTCTTAATGCAA')
# (2, 'CATGGGTGCGTCGATTTTGGCAGTAAAGTGGAATCGTCAGATATCAATCCTGTTTCGTAGAAAGGAGCTACCTAGAGAGGATTACTCTCACATAGTA')
# (3, 'CAAGTCCGCGATAAATTGGAATATTTGTCAATCGGAATAGTCAACTTAGCTGGCGTTAGCTTTACGACTGACAGAGAGAAACCTGTCCATCACACA')
# (4, 'CAAGTCCGGCGTAATTGGAGAATATTTTGCAATCGGAAGATCAATCTTGTTAGCGTTAGCTTACGACTGACGAGAGGGATACTCTCTCTAATACAA')
# (5, 'CACGGGCTCCGCAATTTTGGGTCAAGTTGCATATCAGTCATCGACAATCAAACACTGTTTTGCGGTAGATAAGATACGACTGAGAGAGGACGTTCGCTCGAATATAGTTAC')
# (6, 'CACGGGTCCGTCAATTTTGGAGTAAGTTGATATCGTCACGAAATCAATCCTGTTTCGGTAGTATAGGACTACGACGAGAGAGGACGTTCCTCTGATATAGTTAC')
# Now answer the following:
#
# Write python code to give the length of the longest common subsequence for two strings.
# Generate the table of the lengths of the longest common subsequences for every pair of strings.
# Manually examine the table, and infer the relationships between strings.
# How would you estimate the probabilities of mutation, insertions and deletions? (There might not be enough data to give meaningful estimates, but at least have a clear idea of the approach.)
# Can you devise an algorithm in the general case which might be able to infer such a tree of relationships? Give any strengths or weaknesses of your suggested algorithm.
# Describe the complexity of your solution to identify related genes for this assignment. (Let M be the length of a gene, and N be the number of genes.)
# (Optional) Give differences between this assignment and inferring relationships in real gene sequences.

def LCS_length(X,Y):
    m = len(X)
    n = len(Y)
    b = [[None for _ in range(n)] for _ in range(m)]
    c = [[0 for _ in range(n+1)] for _ in range(m+1)]
    print('m: '+str(m)+ ' n: '+str(n))
    for i in range(m):
        for j in range(n):
            print('i: '+str(i)+' j: '+str(j))
            if X[i] == Y[j]:
                c[i][j] = c[i-1][j-1] + 1
                b[i][j] = 'nw'
            elif c[i-1][j] >= c[i][j-1]:
                c[i][j] = c[i-1][j]
                b[i][j] = 'n'
            else:
                c[i][j] = c[i][j-1]
                b[i][j] = 'w'
    return (c,b)

def print_LCS(b,X,i,j):
    if i == 0 or j == 0:
        return None
    if b[i][j] == 'nw':
        print_LCS(b,X,i-1,j-1)
        print(X[i])
    elif b[i][j] == 'n':
        print_LCS(b,X,i-1,j)
    else:
        print_LCS(b,X,i,j-1)

def LCS_length1(X,Y):
    m = len(X)
    n = len(Y)
    c = [[0 for _ in range(n+1)] for _ in range(m+1)]
    for i in range(m):
        for j in range(n):
            print('i: '+str(i)+' j: '+str(j))
            if X[i] == Y[j]:
                c[i][j] = c[i-1][j-1] + 1
            elif c[i-1][j] >= c[i][j-1]:
                c[i][j] = c[i-1][j]
            else:
                c[i][j] = c[i][j-1]
    return c

A = 'ABCBDAB'
B = 'BDCABA'

print(LCS_length1(A,B)[len(A)-1][len(B)-1])
